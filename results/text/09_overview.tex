В данном разделе мы разберем некоторые особенности библиотек парсер-комбинаторов, а также коснёмся вопросов анализа полученных анализаторов и производительности.

\subsection{Языки реализации парсер-комбинаторов}

Подход парсер-комбинаторов сильно полагается на использование функций высшего порядка для описания функций-анализаторов (далее парсеров), и поэтому наиболее распространен в экосистемах функциональных языков программирования, например, \OCaml{}, \Haskell{} и \Scala{}. Однако встречаются реализации и для классических объектно-ориенти\-ро\-ванных языков, например, \textsc{Boost.Spirit} для \textsc{C++}. 
Особенности реализации среды исполнения данных языков могут оказывать влияние на стиль написания парсера, а также способы тонкой настройки производительности.

\subsection{\ReScript}

Современное развитие сети Интернет  сделало Javascript -- основной язык для программирования для веб-браузеров -- чрезвычайно популярным.  Однако, многим разработчикам он может казаться неудобным, из-за того, что в нём используется слабая динамическая типизация. Поэтому широко исследуются возможности по построению так называемых \emph{траспиляторов} (от англ. transpile): преобразователей из входных языков программирования в Javascript. Наиболее известными проектами на эту тему являются 
\textsc{GHCJS} для Haskell, ClosureScript, Kotlin, Scalajs, 
а также проекты \textsc{Js\_of\_ocaml} и \textsc{Bucklescript} для языка \OCaml{}. \textcolor{red}{Понаставлять ссылок в сноски.}

В инфраструктуре языка \OCaml{} существуют два проекта по транспиляции в \Javascript{} --- это \textsc{Js\_of\_ocaml} и Bucklescript. \Jsoo{} появился первым и в нём порождается код на \Javascript{} из низкоуровнего представляения программ на \OCaml{}, а именно байткода виртуальной машины. За счет такого решения облегчается поддержка проекта при развитии \OCaml{} так как от версии к версии байткод более стабилен чем синтаксис самого языка. Недостатком \Jsoo{} является то, что получающийся код не является человекочитаемым, а также то, что при трансляции слабо учитывается специфика языка и среды исполнения Javascript. 

Другим подходом к порождению \Javascript{} из \OCaml{} является проект \Bucklescript{}. В нём разработчики пошли более сложным путём, чем разработчики \Jsoo{}, а именно создали форк компилятора \OCaml{}, где заменили порождение машинного кода для архитектур x86\_64, ARM и т.п. на порождение Javascript. Проект обрабатывает программы на \OCaml{} пофайлово, и преобразовывает абстрактные синтаксические деревья \OCaml{} в человекочитаемые модули на \Javascript{}. Таким образом, по сравнению с \Jsoo{} в данном проекте увеличена сложность поддержки, но взамен облегчается переиспользование порожденного года другим разработчиками на \Javascript{}, никаким образом не знакомыми с \OCaml{}.


Логическим развитием \Bucklescript{} является \ReasonML{} --- модификация, где синтаксис языка \OCaml{} был изменен таким образом, чтобы быть более знакомым программистам на \Javascript{}. Дополнительно, \ReasonML{} приобрел\footnote{Благодаря Джордану Уолки (Jordan Walke), создателю \textsc{ReactJS}.} специальный синтаксис JSX конструкций для описания разметки HTML, что облегчает его использование для построения UI компонент с помощью ReactJS.
Преимуществом \ReasonML{} является полная синтаксическая совместимость с \OCaml{}: с помощью специальной утилиты можно преобразовывать исходный код на \OCaml{} в \ReasonML{} и наоборот, что упрощает реинжиниринг программ на \OCaml{}.



Однако, часть команды разработчиков \ReasonML{} посчитала полную совместимость с \OCaml{} скорее недостатком, чем достоинством. Во-первых, с точки зрения среды исполнения эффективный код на \OCaml{} может не является таким при исполнении в среде \Javascript{}, например на V8. 
Во-вторых, специфика проектирования интерфейсов функций сильное отличается между языками. В функциональных языках, значение, которое выполняет действие (subject) традиционно передается как последний аргумент, чтобы облегчить композируемость функций. 
В данных обстоятельствах частью разработчиков \ReasonML{} было принято решение отделиться и переименовать \Bucklescript{} в \ReScript{}. Целью нового проекта является создание типобезопасного статически типизированного языка программирования, оптимизированного под нужды и опыт существующих разработчиков на \Javascript{}. Разработчики отказались от сохранения совместимости с \OCaml{}, удалили из языка редко используемые в \ReasonML{} конструкции, в частности, объекты и классы \OCaml{}, и заново реализовали синтаксический анализатор, переключившись с LR-анализатора на вручную написанный рекурсивный спуск.

В данной учебной практике планируется перереализовать синтаксический анализатор \ReScript{} с помощью подхода парсер-комбинаторов. Языком реализации нового синтаксического анализатора будет \ReScript{}, так как исходный анализатор написан на нём. В ходе работы планируется использовать одну из библиотек парсер-комбинаторов, подходящую для использования в языке функционального программирования \ReScript{}. 
Другими компиляторами, которые используют для синтаксического анализа метод рекурсивного спуска и более-менее достойными для реинжиниринга вместо \ReScript{}, можно назвать \textsc{GCC}\footnote{Синтаксический анализатор языка Си в проекта \GCC: \url{https://github.com/gcc-mirror/gcc/blob/releases/gcc-10.3.0/gcc/c/c-parser.c}}, 
\textsc{Typescript}\footnote{\TODO{ссылка}} и \Kotlin{}\footnote{\TODO{ссылка}}.


\subsection{Разновидности библиотек парсер-комбинаторов для языка \OCaml{}}

Для языка \OCaml{} существует некоторое количество библиотек парсер-комбинаторов, большинство из которых спроектировано для 
на основе аналогичных библиотек для языка \Haskell, а именно \textsc{Parsec} и \textsc{Attoparsec}. Эти библиотеки могут различаться в различных аспектах. 



\paragraph{Представление входной последовательности.} Классическим подходом для представления входной последовательности является ленивый список символов, используемый в частности в библиотеке \Parsec{}. Такое представление является простым для реализации и относительно эффективным в среде выполнения языка \Haskell{}, однако его использование в конкурентных системах часто может вызывать сложности, по причине блокирующего ввода-вывода. Из-за этого библиотеки для написания эффективных парсеров с помощью парсер-комбинаторов (например, \textsc{Attoparsec}) часто используют более сложное и низкоуровневое представление входного потока символов.


\paragraph{Сокрытие деталей реализации.}
Несмотря на то, что все парсер-комбинаторы де факто являются функциями языка программирования, информация о том, что они действительно функции может быть сокрыта от программиста. Это часто делается по причине того, что из-за сложного устройства входного потока описание типа парсер-функций может оказываться чересчур сложным, а иногда не типобезопасным. Такое сокрытие происходит в библиотеке парсер-комбинаторов для \OCaml{} под названием \textsc{Angstrom}~\cite{angstrom}. Это может привести к тому, что написание взаимно-рекурсивных парсеров осложняется, появляется необходимость в использовании специального комбинатора неподвижной точки. Этот недостаток более свойственнен языкам со строгой семантикой, в то время как \Haskell{} не возбраняется построение рекурсивных парсеров из других парсеров, не являющихся функциями синтаксически\footnote{\OCaml{} manual: Recursive definitions of values. \url{https://ocaml.org/manual/letrecvalues.html}}.


\paragraph{Предоставление вспомогательной информации для синтаксического анализа.}
От синтаксического анализа зачастую требуется предоставлять дополнительную информацию о потоке входных символов, в частности текущую позицию во входном потоке, а также информацию для отладки ошибок синтаксического анализа. Эти особенности повышают удобство написания и отладки синтаксического анализатора, но могут негативно влиять на производительность и потребление памяти. Отчасти из-за этого в некоторых библиотеках парсер-комбинаторов они не поддерживаются.

\paragraph{Вид предоставляемого интерфейса для написания парсеров.}
Наиболее распространенным видом парсер-комбинаторов являются монадические парсер-комбинаторы, которые предоставляют монадический интерфейс. Также парсер-комбинаторы могут быть аппликативными (applicative) и селективными (selective). Мы разберем их подробнее в следующем разделе 


\subsection{Монадические парсер-комбинаторы}

Монадические парсер-комбинаторы~\cite{monparsing} являются наиболее распространенным видом парсер-комбинаторов и поддерживаются большинством библиотек парсер комбинаторов. Их отличительной особенностью является предоставления монадического интерфейса для написания парсеров, который, в сочетании с функциями, определяемыми пользователем, позволяет распознавать перечислимые языки любого класса сложности.

Рассмотрим реализацию комбинатора \verb=many p= с помощью монадических парсер-комбинаторов, который распознает наибольший отрезок входа, разбираемый как последовательность применений парсеров \verb=p=. В расширенной формер Бэкуса-Наура соответствует операции \verb=*=.
%, разделённых парсером \verb=op= для операции. а затем объединяет результаты синтаксического анализа правоассоциативно с помощью операции \verb=op=.

\begin{lstlisting}[language=haskell,numbers=left]
many p  =    (p >>= \h ->
              many p  >>= \tl ->
              return (h:tl))
             <|> return []
\end{lstlisting}

В данном случае парсер-комбинатор распознает в строке 1 первое вхождение парсера \verb=p= (связывая результат с именем \verb=h=), а затем в строке 2 запускается рекурсивно, распознавая остаток входа и связывая его с именем \verb=tl=.
В третьей строке он возвращает результат -- список разобранных значений, конструируя его с помощью \verb=h= и  \verb=tl=. Если парсер \verb=p= ни одного раза не удалось применить,  то в 4й строке возвращается в качестве ответа пустой список.

Основным назначением монадической операции \verb|>>=| (англ. bind), является проверка того, что парсер слева завершился успешно и предоставление для правой части результата разбора слева, анализируя который она может решать каким образом вести анализ дальше. 

Для данного конкретного парсер-комбинатора \verb=many= эта возможность по конктестно-зависимому синтаксическому анализу не нужна, но для синтаксического анализа языков, выходящих из класса контекстно-сво\-бодных, это будет необходимо. Рассмотрим это на примере анализатора языка $a^nb^nc^n$.

\begin{lstlisting}[language=haskell,numbers=left]
anbncn =
  many (char 'a') >>= \ ac ->
  let len = length ac in
  count len (char 'b') >>= \_ ->
  count len (char 'c') >>= \_ -> return len
\end{lstlisting}

Здесь мы разбираем максимально длинное вхождение символов \verb='a'=, вычисляем его длину в строке 3, а затем пытаемся разобрать фиксированное количество символов \verb='a'= и \verb='b'= в строках 4 и 5 с помощью комбинатора \verb=count=.

Основными преимуществами монадических парсер-комбинаторов является возможность анализа языков произвольной сложности и простота написания парсер (оносительно других видов парсер-комбинаторов). Недостатком можно назвать повсеместное написание кода внутри $\lambda$-абстракций, что осложняет статический анализ парсера.

\subsection{Аппликативные парсер-комбинаторы}

Монадические парсер-комбинаторы являются частным случаем более широкого класса парсер-комбинаторов, называемых аппликативными.
У них вместо функции \verb|>>=| используется функция 
\verb|(<*>)| с типом \\
\verb|Applicative f => f (a -> b) -> f a -> f b|, которая позволяет применить парсер, распознающий какую-то функцию, к парсеру распознающему какой-то аргумент этой функции, и получить парсер, распознающий результат применения этой функции к аргументу. Рассмотрим реализацию парсер-комбинатора \verb=many= в аппликативном стиле.
 
\begin{lstlisting}[language=haskell]
many p = pure (:) <*> p <*> (many p)
\end{lstlisting}
\noindent Как мы видим, создается парсер \verb=pure (:)=, возвращающий операцию присоединения элемента в голову списка,
затем запускаются парсеры \verb=p= и \verb=mymany=. Разобранные два аргумента функции \verb=(:)= применяются с помощью двойного использования оператора \verb=<*>=.

Для данной реализации мы видим, что результатам вызовов двух парсеров не присваивается никакое имя, и поэтому статически компилятор может понять, что вычисление \verb=many p= никак не зависит от результата парсера \verb=p= и, например, при известном \verb=p= выражение \verb=many p= может быть заменено на более оптимизированную реализацию.

С помощью аппликативных парсеров можно разбирать произвольные контекстно-свободные языки. Контекстные зависимые, например, $a^nb^nc^n$ тоже можно разбирать, но это выглядит неестественно, к тому же теряются~\cite{CS_applicative} возможности по статическому анализу.


\subsection{Селективные парсер-комбинаторы}

Парсер-комбинаторы на основе селективных функторов~\cite{selective} занимают промежуточное положение между аппликативными и монадическими парсерами. Их отличительной особенностью является специальный комбинатор 
\verb=branch=, который позволяет изучить результат последнего парсера и выбрать как разбирать остаток входа. Селективные парсер-ком\-бинаторы~\cite{parsley2020} позволяют реализовать большое количество полезных на практике контексто-зависимых парсеров, сохраняя при этом возможности статического анализа парсера.


\subsection{Анализ и оптимизация парсеров}

Анализ с помощью парсер-комбинаторов, также как рекурсивный спуск и леворекурсивные грамматики, может иногда не завершатся. Для монадических парсер-комбинаторов задача проверки завершаемости не разрешима статически, но разрешима во время исполнения. В работе~\cite{meerkat} был предложен метод детектирования неостанавливающихся парсеров во время исполнения. Этот подход был адаптирован~\cite{borovkov} для языка \OCaml{}, однако на данный момент накладные расходы на этот анализ значительны.

Работа~\cite{parsley2020} исследует в том числе применение staging для оптимизации селективных парсер-комбинаторов в языке \Haskell{}. Сутью подхода является выявление в парсер-комбинаторном парсере информации, известной на этапе компиляции, т.е. статически. С помощью неё модернизируются код парсера, путём подстановки известных данных вместо аргументов, а также путём преобразования парсера в абстрактную машину и последующего порождения низкоуровневого кода. В результате этого умеьшаются накладные расходы на вызов функций высшего порядка и получающиеся парсеры начинают показывать производительность сходную с LR-анализаторами.

Использование staging также исследовалось применительно для языка \OCaml{} в работе~\cite{yallop2019}, где подход применялся к парсерам контекстно-свободных языков, т.е. к более узкому классу, чем в работе~\cite{parsley2020}.



