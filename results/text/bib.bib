@article{monparsing,
 author = {Hutton, Graham and Meijer, Erik},
 title = {Monadic Parser Combinators},
 year = {1996},
 doi = {10.1.1.2.4159},
}

@article{borovkov,
 author = {Боровков, Д.},
 title = {Левая рекурсия в монадических парсер-комбинаторах },
 year = {2018},
 url={https://oops.math.spbu.ru/SE/diploma/2018/bmo/444-Borovkov-report.pdf},
  urldate = {2021-04-04},
}

@inproceedings{yallop2019,
author = {Krishnaswami, Neelakantan R. and Yallop, Jeremy},
title = {A Typed, Algebraic Approach to Parsing},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314625},
doi = {10.1145/3314221.3314625},
abstract = {In this paper, we recall the definition of the context-free expressions (or µ-regular expressions), an algebraic presentation of the context-free languages. Then, we define a core type system for the context-free expressions which gives a compositional criterion for identifying those context-free expressions which can be parsed unambiguously by predictive algorithms in the style of recursive descent or LL(1). Next, we show how these typed grammar expressions can be used to derive a parser combinator library which both guarantees linear-time parsing with no backtracking and single-token lookahead, and which respects the natural denotational semantics of context-free expressions. Finally, we show how to exploit the type information to write a staged version of this library, which produces dramatic increases in performance, even outperforming code generated by the standard parser generator tool ocamlyacc.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {379–393},
numpages = {15},
keywords = {context-free languages, Kleene algebra, type theory, parsing},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@article{CS_applicative,
 author = {Yorgey, Brent},
 title = {Parsing context-sensitive languages with Applicative},
 year = {2012},
 urldate = {2021-04-04},
 howpublished = {\url{https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/}},
 url={https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative},
}

@article{selective,
author = {Mokhov, Andrey and Lukyanov, Georgy and Marlow, Simon and Dimino, Jeremie},
title = {Selective Applicative Functors},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341694},
doi = {10.1145/3341694},
abstract = {Applicative functors and monads have conquered the world of functional programming by providing general and powerful ways of describing effectful computations using pure functions. Applicative functors provide a way to compose independent effects that cannot depend on values produced by earlier computations, and all of which are declared statically. Monads extend the applicative interface by making it possible to compose dependent effects, where the value computed by one effect determines all subsequent effects, dynamically.  This paper introduces an intermediate abstraction called selective applicative functors that requires all effects to be declared statically, but provides a way to select which of the effects to execute dynamically. We demonstrate applications of the new abstraction on several examples, including two industrial case studies.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {90},
numpages = {29},
keywords = {selective functors, effects, applicative functors, monads}
}

@article{parsley2020,
author = {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
title = {Staged Selective Parser Combinators},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3409002},
doi = {10.1145/3409002},
abstract = {Parser combinators are a middle ground between the fine control of hand-rolled parsers and the high-level almost grammar-like appearance of parsers created via parser generators. They also promote a cleaner, compositional design for parsers. Historically, however, they cannot match the performance of their counterparts.  This paper describes how to compile parser combinators into parsers of hand-written quality. This is done by leveraging the static information present in the grammar by representing it as a tree. However, in order to exploit this information, it will be necessary to drop support for monadic computation since this generates dynamic structure. Selective functors can help recover lost functionality in the absence of monads, and the parser tree can be partially evaluated with staging. This is implemented in a library called Parsley.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {120},
numpages = {30},
keywords = {parsers, combinators, meta-programming}
}

@inproceedings{meerkat,
author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs van der},
title = {Practical, General Parser Combinators},
year = {2016},
isbn = {9781450340977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2847538.2847539},
doi = {10.1145/2847538.2847539},
abstract = { Parser combinators are a popular approach to parsing where context-free grammars are represented as executable code. However, conventional parser combinators do not support left recursion, and can have worst-case exponential runtime. These limitations hinder the expressivity and performance predictability of parser combinators when constructing parsers for programming languages. In this paper we present general parser combinators that support all context-free grammars and construct a parse forest in cubic time and space in the worst case, while behaving nearly linearly on grammars of real programming languages. Our general parser combinators are based on earlier work on memoized Continuation-Passing Style (CPS) recognizers. First, we extend this work to achieve recognition in cubic time. Second, we extend the resulting cubic CPS recognizers to parsers that construct a binarized Shared Packed Parse Forest (SPPF). Our general parser combinators bring the best of both worlds: the flexibility and extensibility of conventional parser combinators and the expressivity and performance guarantees of general parsing algorithms. We used the approach presented in this paper as the basis for Meerkat, a general parser combinator library for Scala. },
booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
pages = {1–12},
numpages = {12},
keywords = {higher-order functions, memoization, left recursion, continuation-passing style, general parsing, Parser combinators},
location = {St. Petersburg, FL, USA},
series = {PEPM '16}
}
