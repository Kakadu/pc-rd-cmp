\subsection{Библиотеки}

Существующий синтаксический анализатор ReScript написан на OCaml и использует версию 4.06.1.
Для <<чистоты>> эксперимента было решено использовать ту же версию.
Это немного ограничивает список возможных для использования библиотек.

Были рассмотрены следующие библиотеки: angstrom, opal, mparser, bark.\TODO{ссылки!}

\subsection{Выбор}

С помощью каждой из библиотек был написан анализатор \JSON{}.
В таблице 1 показано относительное время работы этих анализаторов на нескольких \JSON{}-файлах.
В ячейках --- отношение времени разбора с использованием конкретного анализатора
к времени разбора с помощью библиотеки \textsc{YoJson}, которая использует для синтаксического анализа \JSON{} сочетание утилиты \textsc{ocamllex}\footnote{Аналог \textsc{UNIX} утилиты lex. Распространяется вместе с компилятором \OCaml{}} и рекурсивного спуска.

\TODO{Написать рядом: что такое в столбцах, если это различные входы, то где их искать, на чем это запускалось, каким компилятором компилировалось, по скольким разам бралось среднее значение. В идеале ещё как-то посчитать потребление памяти.
}

\noindent
\begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
        \hline
                           & c1   & c2   & c3   & c4   & c5   & c6   & r    & r-c
        \\\hline
           Angstrom        & 1.1  & 0.97 & 0.97 & 1.05 & 1.13 & 1.28 & 1.13 & 1.5
        \\ Opal            & 1.85 & 1.79 & 1.9  & 2.12 & 2.49 & 3.11 & 2.45 & 3.39
        \\ MParser         & 5.99 & 5.7  & 5.84 & 6.01 & 6.08 & 6.1  & 6.6  & 9.48
        \\ Bark            & 4.26 & 3.97 & 4.05 & 4.19 & 4.35 & 4.4  & 1.75 & 2.26
        \\\hline
    \end{tabular}
    \captionof{table}{Производительность \JSON{}-анализаторов}
\end{center}

Исходя из полученных результатов, для дальнейшей работы была выбрана библиотека angstrom.

\newpage
\subsection{Выбранная библиотека}

Для дальнейшей работы про angstrom важно знать тип парсера:

\begin{lstlisting}[escapechar=!,language=Caml]
    type input = buffer * int
    type 'a failure =
        input -> string -> 'a state
    type ('a, 'r) success =
        input -> 'a -> 'r state

    type 'a t =
        { run : 'r. input -> 'r failure
            -> ('a, 'r) success -> 'r state
        }
\end{lstlisting}

input --- массив байт с позицией в нём,
то есть предполагается отсутствие отдельного прохода лексического анализа.
